- f0.compute_root() in Halide should be translated to
	- Let's assume that f1 is the consumer of f0.
	- f0.before(f1, computation::root_dimension);

- Tuples: translate an assignment of a Tuple to a function
	as the diffinition of multiple computations.
	For example, if you have

	f(i) = Tuple(5,17)

	It should be translated in Tiramisu to two computations

	{f0[i]: 0<=i<N}: 5
	{f1[i]: 0<=i<N}: 17

	Now any reference to f(i).0 (i.e., the first element in
	the tuple f(i)), should be translated into f0(i) or
	something similar.

- parallel(y, val): implemented as two calls to Tiramsiu
	- split(y, y1, y2, val)
	- tag_parallel_level(y1) or tag_parallel_level(y2) (not sure what are the semantics of parallel in Halide).

- reorder_storage():
	- Should be implemented by creating a map that reorders dimensions
	  exactly like we do for the interchange() command in Tiramisu (which
	  interchanges loop nest levels).

- Bound inference
	- An example of how to do bound inference in case of non-affine bounds
	is provided in test_24. Basically, the non-affine bounds are "hidden"
	in constants (in test_24, we create T1 and T2 to hide the non-affine
	bounds).

- Reduction

- Update
	- Use add_update(),
	- An example is provided in test_25.

- store_at()
	- It provides two information (thus it should be translated into
	  a Tiramisu code that expresses these two information):
		-- It indicates the schedule of the allocation (i.e., when
		should we allocate an array). In order to specify the schedule
		of allocation of a buffer buf0, one can call buf0.allocate_at().
		-- The size of the buffer to be allocated, which can be retrieved
		from the loop bounds using:
		computation.get_upper_bound(level)
		computation.get_lower_bound(level)

