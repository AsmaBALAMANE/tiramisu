- f0.compute_root() in Halide should be translated to
	- Let's assume that f1 is the consumer of f0.
	- f0.before(f1, computation::root_dimension);

- Tuples: translate an assignment of a Tuple to a function
	as the diffinition of multiple computations.
	For example, if you have

	f(i) = Tuple(5,17)

	It should be translated in Tiramisu to two computations

	{f0[i]: 0<=i<N}: 5
	{f1[i]: 0<=i<N}: 17

	Now any reference to f(i).0 (i.e., the first element in
	the tuple f(i)), should be translated into f0(i) or
	something similar.

- parallel(y, val): implemented as two calls to Tiramsiu
	- split(y, y1, y2, val)
	- tag_parallel_level(y1) or tag_parallel_level(y2) (not sure what are the semantics of parallel in Halide).

- reorder_storage():
	- Should be implemented by creating a map that reorders dimensions
	  exactly like we do for the interchange() command in Tiramisu (which
	  interchanges loop nest levels).

- Bound inference
	- An example of how to do bound inference in case of non-affine bounds
	is provided in test_24. Basically, the non-affine bounds are "hidden"
	in constants (in test_24, we create T1 and T2 to hide the non-affine
	bounds).

- Reductions and Updates
	- We have 4 cases:
	    Case I- True reduction (where the iterations of the loop update the
	                            same element of "res").
	            res = 0;
	            for (int k=0; k<N; k++)
	                res = res + 1;
	        It should be translated as
	            res[-1] = 0;
        	    for (int k=0; k<N; k++)
        	        res[k] = res[k-1] + 1;
        Case II- False reduction (where the iterations of the loop DO NOT update the
        	                     same element of "res" but update different elements).
        	    for (ry=0; ry<7; ry++)
                      for (rx=0; rx<7; rx++)
                              S0[ry,rx] = 0;
                for (ry=0; ry<7; ry++)
                      for (rx=0; rx<7; rx++)
                              S0[ry,rx] = S0[ry,rx] * 2;
            It should be translated to
                for (ry=0; ry<7; ry++)
                    for (rx=0; rx<7; rx++)
                        S0[ry][rx][0] = 0;
                for (ry=0; ry<7; ry++)
                    for (rx=0; rx<7; rx++)
                        S0[ry][rx][1] = S0[ry][rx][0] * 2;
        Case III- True update
        	    res = 0;
        	    res = res + 1;
        	    res = res + 1;
        	    res = res + 1;
            It should be translated to
         	    res[0] = 0;
         	    res[1] = res[0] + 1;
         	    res[2] = res[1] + 1;
         	    res[3] = res[2] + 1;
        Case IV- False update (a pattern that looks like an update but actually is not an update
                        because each definition in this update defines a diffrent element of the
                        function)
         	    res[0] = 0;
         	    res[1] = 0;
            It should be translated to
         	    res[0] = 0;
                res[1] = 0;
        Case IV- True update and true reduction
                res[0] = 0;
                res[0] = res + 2;
                for (int k=0; k<N; k++)
                    res[0] = res[0] + 1;
            It should be translated to
                res[0][0] = 0;
                res[0][1] = res[0] + 1;
                for (int k=0; k<N; k++)
                    res[0][k] = res[0][k-1] + 1;
    - Rules
        - Reductions and true updates have the same algorithm in general (because both are updates)
        - A true reduction is a special case of an update.  A false reduction is simply an update
        expressed using RDoms in Halide.
        - Algorithm
            - Expand the updated computation by one dimension.
            - Use add_definitions() to declare/add the different updates of the computation.
            - Compute the index that should be used in the newly added dimension (expanded dimension):
                - The index of the first definition is 0.
                - For each update
                    - The index of the RHS (right hand side) of an update is the index of the previous update,
                      because anything on the right hand side is a read, and it means usually "read the value
                      written by the previous update, so we use the index of the previous update".
                    - The index of the LHS (left hand side) of an update  is the index of the previous update + 1,
                       because anything on the left hand side is a write, i.e., a definition, and it means usually
                       "define a new update" and this its index should be a new index.
                       In true reductions, computing the index is different from the general rule.
                       In these reductions, the computation is updated by many iteration of the reduction
                       loop.  In this case we need to adjust the above method.  We should compute
                       the index as follows:
                       for (k = 0; k<N; k++)
                            res[k + previous_index] = res[k-1 + previous_index] + 1;
                    - Computing the index of a false reduction is identical to computing the index of
                    an update. Only true updates are different.
            - In layer III (data mapping), you should eliminate the expanded dimension by mapping
            that dimension to the same buffer element.
                    res[i][expanded_dimension] -> buf[i]
        - False updates do not require any expansion, they should be simply declared using .add_computation()
	- Examples:
	    - Reduction : test_26 and test_54.cpp.
	    - False update: test_25.

- store_at()
	- store_at() in Tiramisu is different from the store_at in Halide.
	A Halide call such as producer.store_at(consumer, level) should
	be translated in Tiramisu to producer.store_at(level). Telling
       Tiramisu about the "consumer" is not useful, since the function store_at
       is not going to schedule the producer anyway. It is only going to
       allocate a buffer and schedule the allocation operation to be executed
       before the producer.  In Tiramisu, we assume that the producer has
       already been scheduled (Layer II) before deciding about where it is
       going to be stored (layer III).
       In my understanding, the "consumer" argument in the case of Halide is
       spurious and is not needed in our case.
