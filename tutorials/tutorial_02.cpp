#include <isl/set.h>
#include <isl/union_map.h>
#include <isl/union_set.h>
#include <isl/ast_build.h>
#include <isl/schedule.h>
#include <isl/schedule_node.h>

#include <coli/debug.h>
#include <coli/core.h>

#include <string.h>
#include <Halide.h>

/* Halide code.
Func blurxy(Func input, Func blur_y) {
	Func blur_x;
	Var x, y, xi, yi;

	// The algorithm - no storage or order
	blur_x(x, y) = input(x, y) + input(x, y);
	blur_y(x, y) = blur_x(x, y) + blur_x(x, y);

	// The schedule - defines order, locality; implies storage
	blur_y.tile(x, y, xi, yi, 256, 32)
		.vectorize(xi, 8).parallel(y);
	blur_x.compute_at(blur_y, x).vectorize(x, 8);
  }
*/

int main(int argc, char **argv)
{
	// Set default coli options.
	coli::global::set_default_coli_options();

	/*
	 * Declare a function fct.
	 * Declare two arguments (coli buffers) for the function: input and blur_y
	 * Declare an invariant for the function.
	 */
	coli::function blurxy("blurxy");
	coli::buffer b_input("b_input", 2, {100,100}, Halide::Int(8), NULL, true, coli::argument::input, &fct);
	coli::buffer b_blury("b_blury", 2, {100,100}, Halide::Int(8), NULL, true, coli::argument::output, &fct);
	coli::invariant N("N", Halide::Expr((int32_t) 100), &fct);

	// Declare the computations of the function fct.
	coli::computation c_blurx("[N]->{c_blurx[i,j]: 0<=i<N and 0<=j<N}", Halide::Expr((uint8_t) 3), &fct);
	coli::computation c_blury("[N]->{c_blury[i,j]: 0<=i<N and 0<=j<N}", Halide::Expr((uint8_t) 7), &fct);

	// Create a memory buffer (2 dimensional).
	coli::buffer b_blurx("b_blurx", 2, {100,100}, Halide::Int(8), NULL, false, coli::argument::internal, &fct);

	// Map the computations to a buffer (i.e. where each computation
	// should be stored in the buffer).
	// This mapping will be updated automaticall when the schedule
	// is applied.  To disable automatic data mapping updates use
	// coli::global::set_auto_data_mapping(false).
	c_blurx.set_access("{c_blurx[i,j]->b_blurx[i,j]}");
	c_blury.set_access("{c_blury[i,j]->b_blury[i,j]}");

	// Dump the iteration domain (input) for the function.
	fct.dump_iteration_domain();

	// Set the schedule of each computation.
	// The identity schedule means that the program order is not modified
	// (i.e. no optimization is applied).
	c_blurx.tile(0,1,2,2);
	c_blurx.tag_parallel_dimension(0);
	c_blury.set_schedule("{blury[i,j]->[i,j]}");
	c_blury.after(c_blurx, coli::computation::root_dimension);

	// Generate the time-processor domain of the computation
	// and dump it on stdout.
	fct.gen_time_processor_domain();
	fct.dump_time_processor_domain();

	// Generate an AST (abstract Syntax Tree)
	fct.gen_isl_ast();

	// Generate Halide statement for the function.
	fct.gen_halide_stmt();

	// If you want to get the generated halide statements, call
	// fct.get_halide_stmts().

	// Dump the Halide stmt generated by gen_halide_stmt()
	// for the function.
	fct.dump_halide_stmt();

	// Generate an object file from the function.
	fct.gen_halide_obj("build/generated_lib_tutorial_01.o");

	return 0;
}
