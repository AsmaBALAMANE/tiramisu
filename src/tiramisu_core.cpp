#include <isl/ctx.h>
#include <isl/aff.h>
#include <isl/set.h>
#include <isl/map.h>
#include <isl/constraint.h>
#include <isl/union_map.h>
#include <isl/union_set.h>
#include <isl/ast_build.h>
#include <isl/schedule.h>
#include <isl/schedule_node.h>

#include <tiramisu/debug.h>
#include <tiramisu/core.h>

#include <string>
#include <algorithm>

namespace tiramisu
{

std::map<std::string, computation *> computations_list;
bool global::auto_data_mapping;

// Used for the generation of new variable names.
int id_counter = 0;

/**
 * Retrieve the access function of the ISL AST leaf node (which represents a
 * computation).  Store the access in computation->access.
 */
isl_ast_node *stmt_code_generator(
    isl_ast_node *node, isl_ast_build *build, void *user);

isl_ast_node *for_code_generator_after_for(
    isl_ast_node *node, isl_ast_build *build, void *user);


std::string generate_new_variable_name();

/**
  * Add a buffer to the function.
  */
void function::add_buffer(std::pair<std::string, tiramisu::buffer *> buf)
{
    assert((buf.first.length()>0) && ("Empty buffer name."));
    assert((buf.second != NULL) && ("Empty buffer."));

    this->buffers_list.insert(buf);
}


/**
 * Construct a function with the name \p name.
 */
function::function(std::string name)
{
    assert((name.length()>0) && ("Empty function name"));

    this->name = name;
    halide_stmt = NULL;
    ast = NULL;
    context_set = NULL;

    // Allocate an ISL context.  This ISL context will be used by
    // the ISL library calls within Tiramisu.
    ctx = isl_ctx_alloc();
};

/**
  * Get the arguments of the function.
  */
// @{
const std::vector<tiramisu::buffer *> &function::get_arguments() const
{
    return function_arguments;
}
// @}

/**
  * Return a map that represents the buffers of the function.
  * The buffers of the function are buffers that are either passed
  * to the function as arguments or are buffers that are declared
  * and allocated within the function itself.
  * The names of the buffers are used as a key for the map.
  */
 // @{
 const std::map<std::string, tiramisu::buffer *> &function::get_buffers() const
 {
    return buffers_list;
 }
 // @}

/**
   * Return a vector of the computations of the function.
   * The order of the computations in the vector does not have any
   * effect on the actual order of execution of the computations.
   * The order of execution of computations is specified through the
   * schedule.
   */
 // @{
 const std::vector<computation *> function::get_computations() const
 {
     return body;
 }
 // @}

 /**
   * Return the context of the function. i.e. an ISL set that
   * represents constraints over the parameters of the functions
   * (a parameter is an invariant of the function).
   * An example of a context set is the following:
   *          "[N,M]->{: M>0 and N>0}"
   * This context set indicates that the two parameters N and M
   * are strictly positive.
   */
  isl_set *function::get_parameter_set() const
  {
      if (context_set != NULL)
          return isl_set_copy(context_set);
      else
          return NULL;
  }

 /**
   * Get the name of the function.
   */
 const std::string &function::get_name() const
 {
     return name;
 }

 /**
   * Return a vector representing the invariants of the function
   * (symbolic constants or variables that are invariant to the
   * function i.e. do not change their value during the execution
   * of the function).
   */
 // @{
 const std::vector<tiramisu::constant> &function::get_invariants() const
 {
     return invariants;
 }
 // @}

 /**
   * Return the Halide statement that represents the whole
   * function.
   * The Halide statement is generated by the code generator.
   * This function should not be called before calling the code
   * generator.
   */
 Halide::Internal::Stmt function::get_halide_stmt() const
 {
     assert((halide_stmt != NULL) && ("Empty Halide statement"));

     return *halide_stmt;
 }

 /**
   * Return the isl context associated with this function.
   */
 isl_ctx *function::get_ctx() const
 {
     return ctx;
 }

 /**
   * Return the isl ast associated with this function.
   */
 isl_ast_node *function::get_isl_ast() const
 {
     assert((ast != NULL) && ("You should generate an ISL ast first (gen_isl_ast())."));

     return ast;
 }

 /**
 * Get the iterator names of the function.
 */
 const std::vector<std::string>& function::get_iterator_names() const
 {
   return iterator_names;
 }


 /**
   * Return true if the computation \p comp should be parallelized
   * at the loop level \p lev.
   */
 bool function::should_parallelize(std::string comp, int lev) const
 {
     assert(comp.length() > 0);
     assert(lev >= 0);

     bool found = false;

     for (const auto &pd: this->parallel_dimensions)
     {
         if ((pd.first == comp) && (pd.second == lev))
         {
             found = true;
         }
     }

     return found;
 }


 /**
   * Return true if the computation \p comp should be vectorized
   * at the loop level \p lev.
   */
 bool function::should_vectorize(std::string comp, int lev) const
 {
     assert(comp.length() > 0);
     assert(lev >= 0);

     bool found = false;

     for (const auto &pd: this->vector_dimensions)
     {
         if ((pd.first == comp) && (pd.second == lev))
         {
             found = true;
         }
     }

     return found;
 }


 void function::set_context_set(isl_set *context)
  {
      assert((context != NULL) && "Context is NULL");

      this->context_set = context;
  }

 void function::set_context_set(std::string context_str)
 {
     assert((context_str.length() > 0) && "Context string is empty");

     this->context_set = isl_set_read_from_str(this->get_ctx(),
                                         context_str.c_str());

     assert((context_set != NULL) && "Context set is NULL");
 }

 isl_set *function::get_context_set()
 {
     return this->context_set;
 }

 void function::add_context_constraints(std::string context_str)
  {
      assert((context_str.length() > 0) && "Context string is empty");

      if (this->context_set != NULL)
      {
          this->context_set = isl_set_intersect(this->context_set,
                                            isl_set_read_from_str(this->get_ctx(),
                                                                  context_str.c_str()));
      }
      else
      {
          this->context_set = isl_set_read_from_str(this->get_ctx(), context_str.c_str());
      }

      assert((context_set != NULL) && "Context set is NULL");
  }

 /**
   * Set the iterator names of the function.
   */
 void function::set_iterator_names(const std::vector<std::string>& iteratorNames)
 {
     iterator_names = iteratorNames;
 }

 /**
   * Add an iterator to the function.
   */
 void function::add_iterator_name(const std::string iteratorName)
 {
     iterator_names.push_back(iteratorName);
 }

 /**
    * Generate an object file.  This object file will contain the compiled
    * function.
    * \p obj_file_name indicates the name of the generated file.
    * \p os indicates the target operating system.
    * \p arch indicates the architecture of the target (the instruction set).
    * \p bits indicate the bit-width of the target machine.
    *    must be 0 for unknown, or 32 or 64.
    * For a full list of supported value for \p os and \p arch please
    * check the documentation of Halide::Target
    * (http://halide-lang.org/docs/struct_halide_1_1_target.html).
    * If the machine parameters are not supplied, it will detect one automatically.
    */
  // @{
  void function::gen_halide_obj(std::string obj_file_name) const {
      Halide::Target target = Halide::get_host_target();
      gen_halide_obj(obj_file_name, target.os, target.arch, target.bits);
  }
  // @}



/**
  * Generate an isl AST for the function.
  */
void function::gen_isl_ast()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    // Check that time_processor representation has already been computed,
    // TODO: check that the access was provided.
    assert(this->get_time_processor_domain() != NULL);
    assert(this->get_aligned_identity_schedules() != NULL);


    isl_ctx *ctx = this->get_ctx();
    isl_ast_build *ast_build;

    if (this->get_parameter_set() == NULL)
        ast_build = isl_ast_build_alloc(ctx);
    else
        ast_build = isl_ast_build_from_context(this->get_parameter_set());

    isl_options_set_ast_build_atomic_upper_bound(ctx, 1);
    isl_options_get_ast_build_exploit_nested_bounds(ctx);
    ast_build = isl_ast_build_set_after_each_for(ast_build, &tiramisu::for_code_generator_after_for, NULL);
    ast_build = isl_ast_build_set_at_each_domain(ast_build, &tiramisu::stmt_code_generator, this);

    // Set iterator names
    isl_id_list *iterators = isl_id_list_alloc(ctx,  this->get_iterator_names().size());
    if (this->get_iterator_names().size() > 0)
    {

        std::string name = generate_new_variable_name();
        isl_id *id = isl_id_alloc(ctx, name.c_str(), NULL);
        iterators = isl_id_list_add(iterators, id);

        for (int i = 0; i<this->get_iterator_names().size(); i++)
        {
            name = this->get_iterator_names()[i];
            id = isl_id_alloc(ctx, name.c_str(), NULL);
            iterators = isl_id_list_add(iterators, id);

            name = generate_new_variable_name();
            id = isl_id_alloc(ctx, name.c_str(), NULL);
            iterators = isl_id_list_add(iterators, id);
        }

        ast_build = isl_ast_build_set_iterators(ast_build, iterators);
    }

    // Intersect the iteration domain with the domain of the schedule.
    isl_union_map *umap =
        isl_union_map_intersect_domain(
            isl_union_map_copy(this->get_aligned_identity_schedules()),
            isl_union_set_copy(this->get_time_processor_domain()));

    DEBUG(3, tiramisu::str_dump("Schedule:", isl_union_map_to_str(this->get_schedule())));
    DEBUG(3, tiramisu::str_dump("Iteration domain:", isl_union_set_to_str(this->get_iteration_domain())));
    DEBUG(3, tiramisu::str_dump("Time-Space domain:", isl_union_set_to_str(this->get_time_processor_domain())));
    DEBUG(3, tiramisu::str_dump("Time-Space aligned identity schedule:", isl_union_map_to_str(this->get_aligned_identity_schedules())));
    DEBUG(3, tiramisu::str_dump("Identity schedule intersect Time-Space domain:", isl_union_map_to_str(umap)));
    DEBUG(3, tiramisu::str_dump("\n"));

    this->ast = isl_ast_build_node_from_schedule_map(ast_build, umap);

    isl_ast_build_free(ast_build);

    DEBUG_INDENT(-4);
}


/**
  * A helper function to split a string.
  */
// TODO: Test this function
void split_string(std::string str, std::string delimiter,
          std::vector<std::string> &vector)
{
    size_t pos = 0;
    std::string token;
    while ((pos = str.find(delimiter)) != std::string::npos) {
        token = str.substr(0, pos);
        vector.push_back(token);
        str.erase(0, pos + delimiter.length());
    }
    token = str.substr(0, pos);
    vector.push_back(token);
}


std::string generate_new_variable_name()
{
    return "c" + std::to_string(id_counter++);
}


/**
  * Methods for the computation class.
  */
void tiramisu::computation::tag_parallel_level(int par_dim)
{
    assert(par_dim >= 0);
    assert(this->get_name().length() > 0);
    assert(this->get_function() != NULL);

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    this->get_function()->add_parallel_dimension(this->get_name(), par_dim);

    DEBUG_INDENT(-4);
}


void tiramisu::computation::tag_gpu_levels(int dim0, int dim1)
{
    assert(dim0 >= 0);
    assert(dim1 >= 0);
    assert(dim1 == dim0 + 1);
    assert(this->get_name().length() > 0);
    assert(this->get_function() != NULL);

    this->get_function()->add_gpu_dimensions(this->get_name(), dim0, dim1);
}

void tiramisu::computation::tag_vector_level(int dim)
{
    assert(dim >= 0);
    assert(this->get_name().length() > 0);
    assert(this->get_function() != NULL);

    this->get_function()->add_vector_dimension(this->get_name(), dim);
}

void tiramisu::computation::tag_unroll_level(int level)
{
    assert(level >= 0);
    assert(this->get_name().length() > 0);
    assert(this->get_function() != NULL);

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    this->get_function()->add_unroll_dimension(this->get_name(), level);

    DEBUG_INDENT(-4);
}


void tiramisu::computation::separate(int dim, tiramisu::constant &C)
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    assert(this->get_function()->get_computation_by_name("_"+this->get_name()) == NULL);

    // Create the separated computation.
    // First, create the domain of the separated computation (which is identical to
    // the domain of the original computation).
    std::string domain_str = std::string(isl_set_to_str(this->get_iteration_domain()));
    int pos0 = domain_str.find(this->get_name());
    int len0 = this->get_name().length();
    domain_str.replace(pos0, len0, "_"+this->get_name());

    // TODO: create copy functions for all the classes so that we can copy the objects
    // we need to have this->get_expr().copy()
    tiramisu::computation *new_c = new tiramisu::computation(domain_str,
                                                             this->get_expr(),
                                                             this->should_schedule_this_computation(),
                                                             this->get_data_type(),
                                                             this->get_function());

    DEBUG(3, tiramisu::str_dump("Separated computation:\n"); new_c->dump());

    // Create the access relation of the separated computation (by replacing its name).
    std::string access_c_str = std::string(isl_map_to_str(this->get_access_relation()));
    int pos1 = access_c_str.find(this->get_name());
    int len1 = this->get_name().length();
    access_c_str.replace(pos1, len1, "_"+this->get_name());
    new_c->set_access(access_c_str);

    //TODO: for now we are not adding the new parameter to all the access functions,
    // iteration domains, schedules, ... We should either add it every where or transform
    // it into a variable (which is a way better method since it will allow us to
    // vectorize code that has a variable as loop bound (i<j).
    // We can use isl_space_align_params to align all the parameters.

    DEBUG(3, tiramisu::str_dump("Access of the separated computation:", isl_map_to_str(new_c->get_access_relation())));

    // Create the constraints i<M and i>=M. To do so, first we need to create
    // the space of the constraints, which is identical to the space of the
    // iteration domain plus a new dimension that represents the separator
    // parameter.

    // First we create the space.
    isl_space *sp = isl_space_copy(isl_set_get_space(this->get_iteration_domain()));
    sp = isl_space_add_dims(sp, isl_dim_param, 1);
    int pos = isl_space_dim(sp, isl_dim_param) - 1;
    sp = isl_space_set_dim_name(sp, isl_dim_param, pos, C.get_name().c_str());
    isl_local_space *ls = isl_local_space_from_space(isl_space_copy(sp));

    // Second, we create the constraint i<M and add it to the original computation.
    // Since constraints in ISL are of the form X>=y, we transform the previous
    // constraint as follows
    // i <  M
    // i <= M-1
    // M-1-i >= 0
    isl_constraint *cst_upper = isl_constraint_alloc_inequality(isl_local_space_copy(ls));
    cst_upper = isl_constraint_set_coefficient_si(cst_upper, isl_dim_set, dim, -1);
    cst_upper = isl_constraint_set_coefficient_si(cst_upper, isl_dim_param, pos, 1);
    cst_upper = isl_constraint_set_constant_si(cst_upper, -1);

    this->set_iteration_domain(isl_set_add_constraint(this->get_iteration_domain(), cst_upper));

    // Third, we create the constraint i>=M and add it to the newly created computation.
    // i >= M
    // i - M >= 0
    isl_space *sp2 = isl_space_copy(isl_set_get_space(new_c->get_iteration_domain()));
    sp2 = isl_space_add_dims(sp2, isl_dim_param, 1);
    int pos2 = isl_space_dim(sp2, isl_dim_param) - 1;
    sp2 = isl_space_set_dim_name(sp2, isl_dim_param, pos2, C.get_name().c_str());
    isl_local_space *ls2 = isl_local_space_from_space(isl_space_copy(sp2));
    isl_constraint *cst_lower = isl_constraint_alloc_inequality(isl_local_space_copy(ls2));
    cst_lower = isl_constraint_set_coefficient_si(cst_lower, isl_dim_set, dim, 1);
    cst_lower = isl_constraint_set_coefficient_si(cst_lower, isl_dim_param, pos, -1);

    new_c->set_iteration_domain(isl_set_add_constraint(new_c->get_iteration_domain(), cst_lower));

    // Mark the separated computation to be executed after the original (full)
    // computation.
    new_c->after(*this, dim);

    DEBUG_INDENT(-4);
}

void tiramisu::computation::set_iteration_domain(isl_set *domain)
{
    this->iteration_domain = domain;
}

void tiramisu::computation::vectorize(int L0, int v,
                                      tiramisu::expr loop_upper_bound)
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    /*
     * Create a new Tiramisu constant M = w*floor(N/w). This is the biggest
     * multiple of w that is still smaller than N.  Add this constant to
     * the list of invariants.
     */
    std::string separator_name = tiramisu::generate_new_variable_name();
    tiramisu::expr div_expr = tiramisu::expr(o_div, loop_upper_bound,
                                                    tiramisu::expr(v));
    tiramisu::expr cast_expr = tiramisu::expr(o_cast, tiramisu::p_float32, div_expr);
    tiramisu::expr floor_expr = tiramisu::expr(o_floor, cast_expr);
    tiramisu::expr cast2_expr = tiramisu::expr(o_cast, tiramisu::p_int32, floor_expr);
    tiramisu::expr separator_expr = tiramisu::expr(o_mul, tiramisu::expr(v), cast2_expr);

    tiramisu::constant *separation_param = new tiramisu::constant(
                    separator_name, separator_expr, p_uint32, true,
                    NULL, 0, this->get_function());

    /**
     * Add the following constraints about the separator to the context:
     *  -  separator%v = 0
     *  -  separator <= loop_upper_bound
     */

    // Create a new context set.
    std::string constraint_parameters = "[" + separation_param->get_name() +
                                        "," + loop_upper_bound.get_name()  + "]->";
    std::string constraint = constraint_parameters +
            "{ : (" + separation_param->get_name() + ") % " + std::to_string(v) + " = 0 and " +
                "(" + separation_param->get_name() + ") <= " + loop_upper_bound.get_name() +
                " and (" + separation_param->get_name() + ") > 0 and " +
                loop_upper_bound.get_name() + " > 0 " +
            " }";

    isl_set *new_context_set = isl_set_read_from_str(this->get_ctx(), constraint.c_str());

    /*
     * Align the parameters of this set with the parameters of the iteration domain
     * (that is, we have to add the new parameter to the context and then take
     * its space as a model for alignment).
     */
    isl_set *original_context = this->get_function()->get_context_set();
    if (original_context != NULL)
    {
        // Create a space from the context and add a parameter.
        isl_space *sp = isl_space_copy(isl_set_get_space(original_context));
        sp = isl_space_add_dims(sp, isl_dim_param, 1);
        int pos = isl_space_dim(sp, isl_dim_param) - 1;
        sp = isl_space_set_dim_name(sp, isl_dim_param, pos, separator_name.c_str());

        this->set_iteration_domain(
                isl_set_align_params(
                        this->get_iteration_domain(),
                        isl_space_copy(sp)));

        this->get_function()->set_context_set(
                isl_set_align_params(
                       this->get_function()->get_context_set(),
                       isl_space_copy(sp)));

        this->get_function()->set_context_set(
                isl_set_intersect(
                        isl_set_copy(original_context),
                        new_context_set));
    }
    else
    {
        this->get_function()->set_context_set(new_context_set);
    }


    /*
     * Separate this computation using the parameter separation_param. That
     * is create two identical computations where we have a constraint like
     * i<M in the first and i>=M in the second.
     * The first is called the full computation while the second is called
     * the separated computation.
     * The names of the two computations is different. The name of the separated
     * computation is equal to the name of the full computation prefixed with "_".
     */
    this->separate(L0, *separation_param);

    /**
     * Split the full computation since the full computation will be vectorized.
     */
    this->split(L0, v);

    // Tag the inner loop after splitting to be vectorized. That loop
    // is supposed to have a constant extent.
    this->tag_vector_level(L0+1);
    this->get_function()->align_schedules();

    DEBUG_INDENT(-4);
}


void computation::dump_iteration_domain() const
{
    if (ENABLE_DEBUG)
    {
        isl_set_dump(this->get_iteration_domain());
    }
}

void function::dump_halide_stmt() const
{
    if (ENABLE_DEBUG)
    {
        tiramisu::str_dump("\n\n");
        tiramisu::str_dump("\nGenerated Halide Low Level IR:\n");
        std::cout << this->get_halide_stmt();
        tiramisu::str_dump("\n\n\n\n");
    }
}


void function::dump_time_processor_domain() const
{
    // Create time space domain

    if (ENABLE_DEBUG)
    {
        tiramisu::str_dump("\n\nTime-processor domain:\n");

        tiramisu::str_dump("Function " + this->get_name() + ":\n");
        for (const auto &comp : this->get_computations())
        {
            isl_set_dump(comp->get_time_processor_domain());
        }

        tiramisu::str_dump("\n\n");
    }
}

void function::gen_time_processor_domain()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    this->align_schedules();

    for (auto &comp: this->get_computations())
    {
        comp->gen_time_processor_domain();
    }

    DEBUG_INDENT(-4);
}

void computation::dump_schedule() const
{
    if (ENABLE_DEBUG)
    {
        isl_map_dump(this->schedule);
    }
}

void computation::dump() const
{
    if (ENABLE_DEBUG)
    {
        std::cout << "Iteration domain \"" << this->name << "\"" << std::endl;
        isl_set_dump(this->get_iteration_domain());
        std::cout << "Schedule " << std::endl;
        isl_map_dump(this->schedule);
        if (this->get_time_processor_domain() != NULL)
        {
            std::cout << "Time-space domain " << std::endl;
            isl_set_dump(this->get_time_processor_domain());
        } else
            std::cout << "Time-space domain : NULL." << std::endl;

        std::cout << "Computation to be scheduled ? " << (this->schedule_this_computation) << std::endl;

        // std::cout << "Computation expression: " << std::endl;
        // this->expression->dump(true);

        for (auto e: this->index_expr)
        {
            tiramisu::str_dump("Access expression:", (const char * ) isl_ast_expr_to_C_str(e));
            tiramisu::str_dump("\n");
        }

        tiramisu::str_dump("Halide statement:\n");
        if (this->stmt.defined())
        {
            std::cout << this->stmt;
        }
        else
        {
            tiramisu::str_dump("NULL");
        }
        tiramisu::str_dump("\n");
    }
}

void computation::set_schedule(std::string map_str)
{
    assert(map_str.length() > 0);
    assert(this->ctx != NULL);

    isl_map *map = isl_map_read_from_str(this->ctx, map_str.c_str());
    assert(map != NULL);

    this->set_schedule(map);
}


isl_map *isl_map_set_const_dim(isl_map *map, int dim_pos, int val)
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    assert(map != NULL);
    assert(dim_pos >= 0);
    assert(dim_pos <= (signed int) isl_map_dim(map, isl_dim_out));

    DEBUG(3, tiramisu::str_dump("Setting the constant coefficient of ",
                            isl_map_to_str(map));
             tiramisu::str_dump(" at dimension ");
             tiramisu::str_dump(std::to_string(dim_pos));
             tiramisu::str_dump(" into ");
             tiramisu::str_dump(std::to_string(val)));

    isl_space *sp = isl_map_get_space(map);
    isl_local_space *lsp =
        isl_local_space_from_space(isl_space_copy(sp));

    isl_map *identity = isl_set_identity(isl_map_range(isl_map_copy(map)));
    identity = isl_map_universe(isl_map_get_space(identity));

    sp = isl_map_get_space(identity);
    lsp = isl_local_space_from_space(isl_space_copy(sp));

    for (int i=0; i<isl_map_dim(identity, isl_dim_out); i++)
        if (i == dim_pos)
        {
            isl_constraint *cst = isl_constraint_alloc_equality(isl_local_space_copy(lsp));
            cst = isl_constraint_set_coefficient_si(cst, isl_dim_out, dim_pos, 1);
            cst = isl_constraint_set_constant_si(cst, (-1)*(val));
            identity = isl_map_add_constraint(identity, cst);
        }
        else
        {
            isl_constraint *cst2 = isl_constraint_alloc_equality(isl_local_space_copy(lsp));
            cst2 = isl_constraint_set_coefficient_si(cst2, isl_dim_in, i, 1);
            cst2 = isl_constraint_set_coefficient_si(cst2, isl_dim_out, i, -1);
            identity = isl_map_add_constraint(identity, cst2);
        }

    DEBUG(3, tiramisu::str_dump("Transformation map ", isl_map_to_str(identity)));

    map = isl_map_apply_range(map, identity);

    DEBUG(3, tiramisu::str_dump("After applying the transformation map: ",
                            isl_map_to_str(map)));

    DEBUG_INDENT(-4);

    return map;
}


isl_map *isl_map_add_dim_and_eq_constraint(isl_map *map, int dim_pos, int constant)
{
    assert(map != NULL);
    assert(dim_pos >= 0);
    assert(dim_pos <= (signed int) isl_map_dim(map, isl_dim_out));

    map = isl_map_insert_dims(map, isl_dim_out, dim_pos, 1);
    map = isl_map_set_tuple_name(map, isl_dim_out, isl_map_get_tuple_name(map, isl_dim_in));

    isl_space *sp = isl_map_get_space(map);
    isl_local_space *lsp =
        isl_local_space_from_space(isl_space_copy(sp));
    isl_constraint *cst = isl_constraint_alloc_equality(lsp);
    cst = isl_constraint_set_coefficient_si(cst, isl_dim_out, dim_pos, 1);
    cst = isl_constraint_set_constant_si(cst, (-1)*constant);
    map = isl_map_add_constraint(map, cst);

    return map;
}

/**
 * Transform the loop level into its corresponding dynamic schedule
 * dimension.
 *
 * In the example below, the dynamic dimension that corresponds
 * to the loop level 0 is 1, and to 1 it is 3, ...
 *
 * Loop level               :    -1      0      1      2
 * Schedule dimension number:        0   1  2   3  4   5  6
 * Schedule:                        [0, i1, 0, i2, 0, i3, 0]
 */
int loop_level_into_dynamic_dimension(int level)
{
    return level*2+1;
}

/**
 * Transform the loop level into the first static schedule
 * dimension after its corresponding dynamic dimension.
 *
 * In the example below, the first static dimension that comes
 * after the corresponding dynamic dimension for
 * the loop level 0 is 2, and to 1 it is 4, ...
 *
 * Loop level               :    -1      0      1      2
 * Schedule dimension number:        0   1  2   3  4   5  6
 * Schedule:                        [0, i1, 0, i2, 0, i3, 0]
 */
int loop_level_into_static_dimension(int level)
{
    return loop_level_into_dynamic_dimension(level) + 1;
}


/**
  * Implementation internals.
  *
  * This function gets as input a loop level and translates it
  * automatically to the appropriate schedule dimension by:
  * (1) getting the dynamic schedule dimension that corresponds to
  * that loop level, then adding +1 which corresponds to the first
  * static dimension that comes after the dynamic dimension.
  *
  * Explanation of what static and dynamic dimensions are:
  * In the time-processor domain, dimensions can be either static
  * or dynamic.  Static dimensions are used to order statements
  * within a given loop level while dynamic dimensions represent
  * the actual loop levels.  For example, the computations c0 and
  * c1 in the following loop nest
  *
  * for (i=0; i<N: i++)
  *   for (j=0; j<N; j++)
  *   {
  *     c0;
  *     c1;
  *   }
  *
  * have the following representations in the iteration domain
  *
  * {c0(i,j): 0<=i<N and 0<=j<N}
  * {c1(i,j): 0<=i<N and 0<=j<N}
  *
  * and the following representation in the time-processor domain
  *
  * {c0[0,i,0,j,0]: 0<=i<N and 0<=j<N}
  * {c1[0,i,0,j,1]: 0<=i<N and 0<=j<N}
  *
  * The first dimension (dimension 0) in the time-processor
  * representation (the leftmost dimension) is a static dimension,
  * the second dimension (dimension 1) is a dynamic dimension that
  * represents the loop level i, ..., the forth dimension is a dynamic
  * dimension that represents the loop level j and the last dimension
  * (dimension 4) is a static dimension and allows the ordering of
  * c1 after c0 in the loop nest.
  *
  * \p dim has to be a static dimension, i.e. 0, 2, 4, 6, ...
  */
void computation::after(computation &comp, int level)
{
    isl_map *sched1;

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    // for loop level i return 2*i+1 which represents the
    // the static dimension just after the dynamic dimension that
    // represents the loop level i.
    int dim = loop_level_into_static_dimension(level);

    DEBUG(3, tiramisu::str_dump("Setting the schedule of ");
             tiramisu::str_dump(this->get_name());
             tiramisu::str_dump(" after ");
             tiramisu::str_dump(comp.get_name());
             tiramisu::str_dump(" at dimension ");
             tiramisu::str_dump(std::to_string(dim)));

    std::vector<std::pair<int, tiramisu::computation *>> ordered_computations;

    comp.get_function()->align_schedules();

    // Go through all the computations.
    for (auto c: this->get_function()->get_computations())
    {
        sched1 = c->get_schedule();

        DEBUG(3, tiramisu::str_dump("Preparing to adjust the schedule of the computation ");
                 tiramisu::str_dump(c->get_name()));
        DEBUG(3, tiramisu::str_dump("Original schedule: ", isl_map_to_str(sched1)));

        assert(sched1 != NULL);
        DEBUG(3, tiramisu::str_dump("Dimension level in which ordering dimensions will be inserted : ");
                 tiramisu::str_dump(std::to_string(dim)));
        DEBUG(3, tiramisu::str_dump("Original number of dimensions of the schedule : ");
                 tiramisu::str_dump(std::to_string(isl_map_dim(sched1, isl_dim_out))));
        assert(dim < (signed int) isl_map_dim(sched1, isl_dim_out));
        assert(dim >= computation::root_dimension);

        // Update relative orders.
        c->relative_order = c->relative_order*10;
        if ((c != &comp))
            c->relative_order = c->relative_order + 1;

        DEBUG(3, tiramisu::str_dump("Calculated relative order: ");
                 tiramisu::str_dump(std::to_string(c->relative_order)));

        DEBUG(3, tiramisu::str_dump("Adding the computation to the vector of ordered computations."));

        ordered_computations.push_back(std::pair<int, tiramisu::computation *>(c->relative_order, c));
    }

    std::sort(ordered_computations.begin(), ordered_computations.end());

    DEBUG(3, tiramisu::str_dump("Setting the schedules according to their orders."));

    int order = 0;
    for (auto c: ordered_computations)
    {
        sched1 = c.second->get_schedule();

        sched1 = isl_map_set_const_dim(sched1, dim, order);
        order++;

        c.second->set_schedule(sched1);
        DEBUG(3, tiramisu::str_dump("Schedule adjusted: ", isl_map_to_str(sched1)));
    }

    DEBUG_INDENT(-4);
}


void computation::first(int level)
{
    isl_map *sched1;

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    int dim = loop_level_into_static_dimension(level);

    this->get_function()->align_schedules();

    // Go through all the computations.
    for (auto c: this->get_function()->get_computations())
    {
        sched1 = c->get_schedule();

        DEBUG(3, tiramisu::str_dump("Adjusting the schedule of a computation ");
                 tiramisu::str_dump(c->get_name()));
        DEBUG(3, tiramisu::str_dump("Original schedule: ", isl_map_to_str(sched1)));

        assert(sched1 != NULL);
        DEBUG(3, tiramisu::str_dump("Dimension level at which the ordering dimension will be inserted : ");
                 tiramisu::str_dump(std::to_string(dim)));
        DEBUG(3, tiramisu::str_dump("Original number of dimensions of the schedule : ");
                 tiramisu::str_dump(std::to_string(isl_map_dim(sched1, isl_dim_out))));
        if (this->statements_to_compute_before_me != NULL)
            DEBUG(3, tiramisu::str_dump("Computation to compute before this computation ");
                         tiramisu::str_dump(this->statements_to_compute_before_me->get_name()));
        assert(dim < (signed int) isl_map_dim(sched1, isl_dim_out));
        assert(dim >= computation::root_dimension);

        // Update relative orders.
        if (c != this && c != this->statements_to_compute_before_me)
            c->relative_order = c->relative_order + 1;

        DEBUG(3, tiramisu::str_dump("Relative order: ");
                 tiramisu::str_dump(std::to_string(c->relative_order)));

        if (c == this || c == this->statements_to_compute_before_me)
        {
            sched1 = isl_map_set_const_dim(sched1, dim, 0);
            DEBUG(3, tiramisu::str_dump("Setting dimension to 0."));
        }
        else
        if (c != this)
        {
            sched1 = isl_map_set_const_dim(sched1, dim, 1);
            DEBUG(3, tiramisu::str_dump("Setting dimension to 1."));
        }

        c->set_schedule(sched1);
        DEBUG(3, tiramisu::str_dump("Schedule adjusted: ", isl_map_to_str(sched1)));
    }

    DEBUG_INDENT(-4);
}


void computation::before(computation &comp, int dim)
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    comp.after(*this, dim);

    DEBUG_INDENT(-4);
}

void computation::tile(int L0, int L1,
                       int sizeX, int sizeY)
{
    // Check that the two dimensions are consecutive.
    // Tiling only applies on a consecutive band of loop dimensions.
    assert((L0 == L1+1) || (L1 == L0+1));
    assert(sizeX > 0);
    assert(sizeY > 0);
    assert(L0 >= 0);
    assert(L1 >= 0);
    assert(this->get_iteration_domain() != NULL);
    assert(loop_level_into_dynamic_dimension(L1) < isl_space_dim(isl_map_get_space(this->schedule), isl_dim_out));

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    this->split(L0, sizeX);
    this->split(L1+1, sizeY);
    this->interchange(L0+1, L1+1);

    DEBUG_INDENT(-4);
}

/**
 * This function modifies the schedule of the computation so that the two loop
 * levels L0 and L1 are interchanged (swapped).
 */
void computation::interchange(int L0, int L1)
{
    int inDim0 = loop_level_into_dynamic_dimension(L0);
    int inDim1 = loop_level_into_dynamic_dimension(L1);

    assert(inDim0 >= 0);
    assert(inDim0 < isl_space_dim(isl_map_get_space(this->schedule),
                                  isl_dim_out));
    assert(inDim1 >= 0);
    assert(inDim1 < isl_space_dim(isl_map_get_space(this->schedule),
                                  isl_dim_out));

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_map *schedule = this->get_schedule();

    DEBUG(3, tiramisu::str_dump("Original schedule: ", isl_map_to_str(schedule)));

    int n_dims = isl_map_dim(schedule, isl_dim_out);

    std::string inDim0_str = isl_map_get_dim_name(schedule, isl_dim_out, inDim0);
    std::string inDim1_str = isl_map_get_dim_name(schedule, isl_dim_out, inDim1);

    std::vector<isl_id *> dimensions;

    std::string map = "{ " + this->get_name() + "[";

    for (int i=0; i<n_dims; i++)
    {
        if (isl_map_get_dim_name(schedule, isl_dim_out, i) == NULL)
        {
            isl_id *new_id = isl_id_alloc(this->get_ctx(), generate_new_variable_name().c_str(), NULL);
            schedule = isl_map_set_dim_id(schedule, isl_dim_out, i,new_id);
        }
        map = map + isl_map_get_dim_name(schedule, isl_dim_out, i);
        if (i != n_dims-1)
            map = map + ",";
    }

    map = map + "] ->" + this->get_name() + "[";

    for (int i=0; i<n_dims; i++)
    {
        if ((i != inDim0) && (i != inDim1))
        {
            map = map + isl_map_get_dim_name(schedule, isl_dim_out, i);
            dimensions.push_back(isl_map_get_dim_id(schedule, isl_dim_out, i));
        }
        else if (i == inDim0)
        {
            map = map + inDim1_str;
            isl_id *id1 = isl_id_alloc(this->get_ctx(), inDim1_str.c_str(), NULL);
            dimensions.push_back(id1);
        }
        else if (i == inDim1)
        {
            map = map + inDim0_str;
            isl_id *id1 = isl_id_alloc(this->get_ctx(), inDim0_str.c_str(), NULL);
            dimensions.push_back(id1);
        }

        if (i != n_dims-1)
            map = map + ",";
    }

    map = map + "]}";

    DEBUG(3, tiramisu::str_dump("Transformation map = ", map.c_str()));

    isl_map *transformation_map = isl_map_read_from_str(this->get_ctx(), map.c_str());
    transformation_map = isl_map_set_tuple_id(
        transformation_map, isl_dim_in, isl_map_get_tuple_id(isl_map_copy(schedule), isl_dim_out));
    isl_id *id_range = isl_id_alloc(this->get_ctx(), this->get_name().c_str(), NULL);
    transformation_map = isl_map_set_tuple_id(
        transformation_map, isl_dim_out, id_range);
    schedule = isl_map_apply_range(isl_map_copy(schedule), isl_map_copy(transformation_map));

    DEBUG(3, tiramisu::str_dump("Schedule after interchange: ", isl_map_to_str(schedule)));

    this->set_schedule(schedule);

    DEBUG_INDENT(-4);
}

/**
 * Modify the schedule of this computation so that it splits the
 * loop level L0 into two new loop levels.
 * The size of the inner dimension created is sizeX.
 */
void computation::split(int L0, int sizeX)
{
    int inDim0 = loop_level_into_dynamic_dimension(L0);

    assert(this->get_schedule() != NULL);
    assert(inDim0 >= 0);
    assert(inDim0 < isl_space_dim(isl_map_get_space(this->get_schedule()), isl_dim_out));
    assert(sizeX >= 1);

    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_map *schedule = this->get_schedule();
    schedule = isl_map_copy(schedule);
    schedule = isl_map_set_tuple_id(schedule, isl_dim_out,
                                    isl_id_alloc(this->get_ctx(), this->get_name().c_str(), NULL));


    DEBUG(3, tiramisu::str_dump("Original schedule: ", isl_map_to_str(schedule)));
    DEBUG(3, tiramisu::str_dump("Splitting dimension " + std::to_string(inDim0)
                            + " with split size " + std::to_string(sizeX)));

    std::string inDim0_str;

    std::string outDim0_str = generate_new_variable_name();
    std::string outDim1_str = generate_new_variable_name();

    int n_dims = isl_map_dim(this->get_schedule(), isl_dim_out);
    std::string map = "{" + this->get_name() + "[";

    std::vector<isl_id *> dimensions;
    std::vector<std::string> dimensions_str;

    for (int i=0; i<n_dims; i++)
    {
        std::string dim_str = generate_new_variable_name();
        dimensions_str.push_back(dim_str);
        map = map + dim_str;

        if (i == inDim0)
            inDim0_str = dim_str;

        if (i != n_dims-1)
            map = map + ",";
    }

    map = map + "] -> " + this->get_name() + "[";

    for (int i=0; i<n_dims; i++)
    {
        if (i != inDim0)
        {
            map = map + dimensions_str[i];
            dimensions.push_back(isl_id_alloc(
                                    this->get_ctx(),
                                    dimensions_str[i].c_str(),
                                    NULL));
        }
        else
        {
            map = map + outDim0_str + ", 0, " + outDim1_str;
            isl_id *id0 = isl_id_alloc(this->get_ctx(),
                                       outDim0_str.c_str(), NULL);
            isl_id *id1 = isl_id_alloc(this->get_ctx(),
                                       outDim1_str.c_str(), NULL);
            dimensions.push_back(id0);
            dimensions.push_back(id1);
        }

        if (i != n_dims-1)
            map = map + ",";
    }

    map = map + "] : " + outDim0_str + " = floor(" + inDim0_str + "/" +
        std::to_string(sizeX) + ") and " + outDim1_str + " = (" +
        inDim0_str + "%" + std::to_string(sizeX) + ")}";

    DEBUG(3, tiramisu::str_dump("Transformation map = ", map.c_str()));

    isl_map *transformation_map = isl_map_read_from_str(this->get_ctx(), map.c_str());

    for (int i=0; i< dimensions.size(); i++)
        transformation_map = isl_map_set_dim_id(
            transformation_map, isl_dim_out, i, isl_id_copy(dimensions[i]));

    transformation_map = isl_map_set_tuple_id(
        transformation_map, isl_dim_in,
        isl_map_get_tuple_id(isl_map_copy(schedule), isl_dim_out));
    isl_id *id_range = isl_id_alloc(this->get_ctx(), this->get_name().c_str(), NULL);
    transformation_map = isl_map_set_tuple_id(transformation_map, isl_dim_out, id_range);
    schedule = isl_map_apply_range(isl_map_copy(schedule), isl_map_copy(transformation_map));

    DEBUG(3, tiramisu::str_dump("Schedule after splitting: ", isl_map_to_str(schedule)));

    this->set_schedule(schedule);

    DEBUG_INDENT(-4);
}

// Methods related to the tiramisu::function class.

std::string tiramisu::function::get_gpu_iterator(std::string comp, int lev0) const
{
   assert(comp.length() > 0);
   assert(lev0 >=0 );

   DEBUG_FCT_NAME(3);
   DEBUG_INDENT(4);

   std::string res = std::string("");;

   for (const auto &pd: this->gpu_dimensions)
   {
      if ((pd.first == comp) && ((pd.second.first == lev0) || (pd.second.second == lev0)))
      {
          if (lev0 == pd.second.first)
              res = std::string("__thread_id_x");
          else if (lev0 == pd.second.second)
              res = std::string("__thread_id_y");
          else
              tiramisu::error("Level not mapped to GPU.", true);

          std::string str = std::string("Dimension ") + std::to_string(lev0)
               + std::string(" should be mapped to iterator ") + res;
          str = str + ". It was compared against: " + std::to_string(pd.second.first)
               + " and " + std::to_string(pd.second.second);
          DEBUG(3, tiramisu::str_dump(str));
       }
   }

   DEBUG_INDENT(-4);
   return res;
}

bool tiramisu::function::should_unroll(std::string comp, int lev0) const
{
      assert(comp.length() > 0);
      assert(lev0 >=0 );

      DEBUG_FCT_NAME(3);
      DEBUG_INDENT(4);

      bool found = false;

      for (const auto &pd: this->unroll_dimensions)
      {
          if ((pd.first == comp) && (pd.second == lev0))
          {
              found = true;
          }
      }

      std::string str = std::string("Dimension ") + std::to_string(lev0)
          + std::string(found?" should":" should not")
          + std::string(" be unrolled.");
      DEBUG(3, tiramisu::str_dump(str));

      DEBUG_INDENT(-4);
      return found;
}


bool tiramisu::function::should_map_to_gpu(std::string comp, int lev0) const
{
      assert(comp.length() > 0);
      assert(lev0 >=0 );

      DEBUG_FCT_NAME(10);
      DEBUG_INDENT(4);

      bool found = false;

      for (const auto &pd: this->gpu_dimensions)
      {
          if ((pd.first == comp) && ((pd.second.first == lev0) || (pd.second.second == lev0)))
          {
              found = true;
          }
      }

      std::string str = std::string("Dimension ") + std::to_string(lev0)
          + std::string(found?" should":" should not")
          + std::string(" be mapped to GPU.");
      DEBUG(10, tiramisu::str_dump(str));

      DEBUG_INDENT(-4);
      return found;
}

int tiramisu::function::get_max_identity_schedules_range_dim() const
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    int max_dim = 0;

    for (const auto &comp : this->get_computations())
    {
        isl_map *sched = comp->gen_identity_schedule_for_time_space_domain();
        int m = isl_map_dim(sched, isl_dim_out);
        max_dim = std::max(max_dim, m);
    }

    DEBUG_INDENT(-4);

    return max_dim;
}


int tiramisu::function::get_max_schedules_range_dim() const
{
    int max_dim = 0;

    for (const auto &comp : this->get_computations())
    {
        int m = isl_map_dim(comp->get_schedule(), isl_dim_out);
        max_dim = std::max(max_dim, m);
    }

    return max_dim;
}

isl_map *isl_map_align_range_dims(isl_map *map, int max_dim)
{
    DEBUG_FCT_NAME(10);
    DEBUG_INDENT(4);

    assert(map != NULL);
    int mdim = isl_map_dim(map, isl_dim_out);
    assert(max_dim >= mdim);

    DEBUG(10, tiramisu::str_dump("Input map:", isl_map_to_str(map)));

    const char *original_range_name = isl_map_get_tuple_name(map, isl_dim_out);

    map = isl_map_add_dims(map, isl_dim_out, max_dim - mdim);

    for (int i=mdim; i<max_dim; i++)
    {
        isl_space *sp = isl_map_get_space(map);
        isl_local_space *lsp =
            isl_local_space_from_space(isl_space_copy(sp));
        isl_constraint *cst = isl_constraint_alloc_equality(lsp);
        cst = isl_constraint_set_coefficient_si(cst, isl_dim_out, i, 1);
        map = isl_map_add_constraint(map, cst);
    }

    map = isl_map_set_tuple_name(map, isl_dim_out, original_range_name);

    DEBUG(10, tiramisu::str_dump("After alignment, map = ",
                isl_map_to_str(map)));

    DEBUG_INDENT(-4);
    return map;
}


isl_union_map *tiramisu::function::get_aligned_identity_schedules() const
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_union_map *result;
    isl_space *space;

    if (this->body.empty() == false)
    {
        space = isl_map_get_space(this->body[0]->gen_identity_schedule_for_time_space_domain());
    }
    else
    {
        return NULL;
    }

    assert(space != NULL);
    result = isl_union_map_empty(isl_space_copy(space));

    int max_dim = this->get_max_identity_schedules_range_dim();

    for (auto &comp : this->get_computations())
    {
        if (comp->should_schedule_this_computation())
        {
            isl_map *sched = comp->gen_identity_schedule_for_time_space_domain();
            DEBUG(3, tiramisu::str_dump("Identity schedule for time space domain: ", isl_map_to_str(sched)));
            assert((sched != NULL) && "Identity schedule could not be computed");
            sched = isl_map_align_range_dims(sched, max_dim);
            result = isl_union_map_union(result, isl_union_map_from_map(sched));
        }
    }

    DEBUG_INDENT(-4);
    DEBUG(3, tiramisu::str_dump("End of function"));

    return result;
}

void tiramisu::function::align_schedules()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    int max_dim = this->get_max_schedules_range_dim();

    for (auto &comp : this->get_computations())
    {
        isl_map *sched = comp->get_schedule();
        assert((sched != NULL) && "Schedules should be set before calling align_schedules");
        sched = isl_map_align_range_dims(sched, max_dim);
        comp->set_schedule(sched);
    }

    DEBUG_INDENT(-4);
    DEBUG(3, tiramisu::str_dump("End of function"));
}

void tiramisu::function::add_invariant(tiramisu::constant invar)
{
    invariants.push_back(invar);
}

void tiramisu::function::add_computation(computation *cpt)
{
    assert(cpt != NULL);

    assert(std::find_if(this->body.begin(), this->body.end(),
                        [&cpt](const computation *c) { return (c->get_name() == cpt->get_name()); }) ==
           this->body.end() &&
           "Found duplicate of the computation.");

    this->body.push_back(cpt);
}


void tiramisu::function::dump(bool exhaustive) const
{
    if (ENABLE_DEBUG)
    {
        std::cout << "\n\nFunction \"" << this->name << "\"" << std::endl;

        std::cout << "Function arguments (tiramisu buffers):" << std::endl;
        for (const auto &buf : this->function_arguments)
        {
            buf->dump(exhaustive);
        }
        std::cout << std::endl;

        std::cout << "Function invariants:" << std::endl;
        for (const auto &inv : this->invariants)
        {
            inv.dump(exhaustive);
        }
        std::cout << std::endl;

        if (this->get_parameter_set() != NULL)
        {
            std::cout << "Function context set: "
                      << isl_set_to_str(this->get_parameter_set())
                      << std::endl;
        }

        this->dump_schedule();

        std::cout << "Body " << std::endl;
        for (const auto &cpt : this->body)
            cpt->dump();

        std::cout<< std::endl;

        if (this->halide_stmt != NULL)
        {
            std::cout << "Halide stmt " << *(this->halide_stmt) << std::endl;
        }

        std::cout << "Buffers" << std::endl;
        for (const auto &buf : this->buffers_list)
        {
            std::cout << "Buffer name: " << buf.second->get_name() << std::endl;
        }

        std::cout << std::endl << std::endl;
    }
}

void tiramisu::function::dump_iteration_domain() const
{
    if (ENABLE_DEBUG)
    {
        tiramisu::str_dump("\nIteration domain:\n");
        for (const auto &cpt : this->body)
            cpt->dump_iteration_domain();
        tiramisu::str_dump("\n");
    }
}

void tiramisu::function::dump_schedule() const
{
    if (ENABLE_DEBUG)
    {
        tiramisu::str_dump("\nSchedule:\n");

        for (const auto &cpt : this->body)
        {
            cpt->dump_schedule();
        }

        std::cout << "Parallel dimensions: ";
        for (const auto &par_dim : parallel_dimensions)
        {
            std::cout << par_dim.first << "(" << par_dim.second << ") ";
        }

        std::cout << std::endl;

        std::cout << "Vector dimensions: ";
        for (const auto &vec_dim : vector_dimensions)
        {
            std::cout << vec_dim.first << "(" << vec_dim.second << ") ";
        }

        std::cout<< std::endl << std::endl << std::endl;
    }
}

Halide::Argument::Kind halide_argtype_from_tiramisu_argtype(tiramisu::argument_t type)
{
    Halide::Argument::Kind res;

    if (type == tiramisu::a_temporary)
        tiramisu::error("Buffer type \"temporary\" can't be translated to Halide.\n", true);

    if (type == tiramisu::a_input)
    {
        res = Halide::Argument::InputBuffer;
    }
    else  // if (type == tiramisu::a_output)
    {
        res = Halide::Argument::OutputBuffer;
    }

    return res;
}

void tiramisu::function::set_arguments(std::vector<tiramisu::buffer *> buffer_vec)
{
    this->function_arguments = buffer_vec;
}

void tiramisu::function::add_vector_dimension(std::string stmt_name, int vec_dim)
{
    assert(vec_dim >= 0);
    assert(stmt_name.length() > 0);

    this->vector_dimensions.push_back(std::pair<std::string,int>(stmt_name, vec_dim));
}

void tiramisu::function::add_parallel_dimension(std::string stmt_name, int vec_dim)
{
    assert(vec_dim >= 0);
    assert(stmt_name.length() > 0);

    this->parallel_dimensions.push_back(std::pair<std::string,int>(stmt_name, vec_dim));
}

void tiramisu::function::add_unroll_dimension(std::string stmt_name, int level)
{
    assert(level >= 0);
    assert(stmt_name.length() > 0);

    this->unroll_dimensions.push_back(std::pair<std::string,int>(stmt_name, level));
}

void tiramisu::function::add_gpu_dimensions(std::string stmt_name, int dim0,
                                        int dim1)
{
    assert(dim0 >= 0);
    assert(dim1 >= 0);
    assert(dim1 == dim0 + 1);
    assert(stmt_name.length() > 0);

    this->gpu_dimensions.push_back(std::pair<std::string, std::pair<int,int>>
                                          (stmt_name,  std::pair<int,int>
                                                         (dim0, dim1)));
}

isl_union_set * tiramisu::function::get_time_processor_domain() const
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_union_set *result = NULL;
    isl_space *space = NULL;

    if (this->body.empty() == false)
    {
        space = isl_set_get_space(this->body[0]->get_time_processor_domain());
    }
    else
    {
        return NULL;
    }

    assert(space != NULL);
    result = isl_union_set_empty(isl_space_copy(space));

    for (const auto &cpt : this->body)
    {
        if (cpt->should_schedule_this_computation())
        {
            isl_set *cpt_iter_space = isl_set_copy(cpt->get_time_processor_domain());
            result = isl_union_set_union(isl_union_set_from_set(cpt_iter_space), result);
        }
    }

    DEBUG_INDENT(-4);

    return result;
}


isl_union_set *tiramisu::function::get_iteration_domain() const
{
    isl_union_set *result = NULL;
    isl_space *space = NULL;

    if (this->body.empty() == false)
    {
        space = isl_set_get_space(this->body[0]->get_iteration_domain());
    }
    else
    {
        return NULL;
    }

    assert(space != NULL);
    result = isl_union_set_empty(isl_space_copy(space));

    for (const auto &cpt : this->body)
    {
        if (cpt->should_schedule_this_computation())
        {
            isl_set *cpt_iter_space = isl_set_copy(cpt->get_iteration_domain());
            result = isl_union_set_union(isl_union_set_from_set(cpt_iter_space), result);
        }
    }

    return result;
}

isl_union_map *tiramisu::function::get_schedule() const
{
    isl_union_map *result = NULL;
    isl_space *space = NULL;

    if (this->body.empty() == false)
    {
        space = isl_map_get_space(this->body[0]->get_schedule());
    }
    else
    {
        return NULL;
    }

    assert(space != NULL);
    result = isl_union_map_empty(isl_space_copy(space));

    for (const auto &cpt : this->body)
    {
        isl_map *m = isl_map_copy(cpt->get_schedule());
        result = isl_union_map_union(isl_union_map_from_map(m), result);
    }

    result = isl_union_map_intersect_domain(result, this->get_iteration_domain());

    return result;
}


// Function for the buffer class

std::string str_tiramisu_type_op(tiramisu::op_t type)
{
    switch (type)
    {
        case tiramisu::o_logical_and:
            return "and";
        case tiramisu::o_logical_or:
            return "or";
        case tiramisu::o_max:
            return "max";
        case tiramisu::o_min:
            return "min";
        case tiramisu::o_minus:
            return "minus";
        case tiramisu::o_add:
            return "add";
        case tiramisu::o_sub:
            return "sub";
        case tiramisu::o_mul:
            return "mul";
        case tiramisu::o_div:
            return "div";
        case tiramisu::o_mod:
            return "mod";
        case tiramisu::o_cond:
            return "cond";
        case tiramisu::o_not:
            return "not";
        case tiramisu::o_eq:
            return "eq";
        case tiramisu::o_ne:
            return "ne";
        case tiramisu::o_le:
            return "le";
        case tiramisu::o_lt:
            return "lt";
        case tiramisu::o_ge:
            return "ge";
        case tiramisu::o_call:
            return "call";
        case tiramisu::o_access:
            return "access";
        case tiramisu::o_right_shift:
            return "right-shift";
        case tiramisu::o_left_shift:
            return "left-shift";
        case tiramisu::o_floor:
            return "floor";
        case tiramisu::o_cast:
            return "cast";
        default:
            tiramisu::error("Tiramisu op not supported.", true);
            return "";
    }
}

std::string str_from_tiramisu_type_expr(tiramisu::expr_t type)
{
    switch (type)
    {
        case tiramisu::e_id:
            return "id";
        case tiramisu::e_val:
            return "val";
        case tiramisu::e_op:
            return "op";
        case tiramisu::e_var:
            return "var";
        default:
            tiramisu::error("Tiramisu type not supported.", true);
            return "";
    }
}

std::string str_from_tiramisu_type_argument(tiramisu::argument_t type)
{
    switch (type)
    {
        case tiramisu::a_input:
            return "input";
        case tiramisu::a_output:
            return "output";
        case tiramisu::a_temporary:
            return "temporary";
        default:
            tiramisu::error("Tiramisu type not supported.", true);
            return "";
    }
}

std::string str_from_tiramisu_type_primitive(tiramisu::primitive_t type)
{
    switch (type)
    {
        case tiramisu::p_uint8:
            return "uint8";
        case tiramisu::p_int8:
            return "int8";
        case tiramisu::p_uint16:
            return "uint16";
        case tiramisu::p_int16:
            return "int16";
        case tiramisu::p_uint32:
            return "uin32";
        case tiramisu::p_int32:
            return "int32";
        case tiramisu::p_uint64:
            return "uint64";
        case tiramisu::p_int64:
            return "int64";
        case tiramisu::p_float32:
            return "float32";
        case tiramisu::p_float64:
            return "float64";
        case tiramisu::p_boolean:
            return "bool";
        default:
            tiramisu::error("Tiramisu type not supported.", true);
            return "";
    }
}

std::string str_from_is_null(void *ptr)
{
    return ((ptr != NULL) ? "Not NULL" : "NULL");
}


/**
  * Create a tiramisu buffer.
  * Buffers have two use cases:
  * - used to store the results of computations, and
  * - used to represent input arguments to functions.
  *
  * \p name is the name of the buffer.
  * \p nb_dims is the number of dimensions of the buffer.
  * A scalar is a one dimensional buffer that has a size of one
  * element.
  * \p dim_sizes is a vector of integers that represent the size
  * of each dimension in the buffer.  The first vector element
  * represents the rightmost array dimension, while the last vector
  * element represents the leftmost array dimension.
  * For example, in the buffer buf[N0][N1][N2], the first element
  * in the vector \p dim_sizes represents the size of rightmost
  * dimension of the buffer (i.e. N2), the second vector element
  * is N1, and the last vector element is N0.
  * Buffer dimensions in Tiramisu have the same semantics as in
  * C/C++.
  * \p type is the type of the elements of the buffer.
  * It must be a primitive type (i.e. p_uint8, p_uint16, ...).
  * Possible types are declared in tiramisu::primitive_t (type.h).
  * \p data is the data stored in the buffer.  This is useful
  * if an already allocated buffer is passed to Tiramisu.
  * \p fct is a pointer to a Tiramisu function where the buffer is
  * declared or used.
  * \p is_argument indicates whether the buffer is passed to the
  * function as an argument.  All the buffers passed as arguments
  * to the function should be allocated by the user outside the
  * function.  Buffers that are not passed to the function as
  * arguments are allocated automatically at the beginning of
  * the function and deallocated at the end of the function.
  * They are called temporary buffers (of type a_temporary).
  * Temporary buffers cannot be used outside the function
  * in which they were allocated.
  */
tiramisu::buffer::buffer(std::string name, int nb_dims, std::vector<tiramisu::expr> dim_sizes,
       tiramisu::primitive_t type, uint8_t *data,
       tiramisu::argument_t argt, tiramisu::function *fct):
    name(name), nb_dims(nb_dims), dim_sizes(dim_sizes), type(type),
    data(data), fct(fct), argtype(argt)
{
    assert(name.length()>0 && "Empty buffer name");
    assert(nb_dims>0 && "Buffer dimensions <= 0");
    assert(nb_dims == dim_sizes.size() && "Mismatch in the number of dimensions");
    assert(fct != NULL && "Input function is NULL");

    // Check that the buffer does not already exist.
    assert((fct->get_buffers().count(name) == 0) && ("Buffer already exists"));

    fct->add_buffer(std::pair<std::string, tiramisu::buffer *>(name, this));
};


/**
  * Return the type of the argument (if the buffer is an argument).
  * Three possible types:
  *  - a_input: for inputs of the function,
  *  - a_output: for outputs of the function,
  *  - a_temporary: for buffers used as temporary buffers within
  *  the function (any temporary buffer is allocated automatically by
  *  the Tiramisu runtime at the entry of the function and is
  *  deallocated at the exit of the function).
  */
tiramisu::argument_t buffer::get_argument_type() const
{
    return argtype;
}


/**
  * Return a pointer to the data stored within the buffer.
  */
uint8_t *buffer::get_data()
{
    return data;
}


/**
  * Return the name of the buffer.
  */
const std::string &buffer::get_name() const
{
    return name;
}


/**
  * Get the number of dimensions of the buffer.
  */
int buffer::get_n_dims() const
{
    return nb_dims;
}


/**
  * Return the type of the elements of the buffer.
  */
tiramisu::primitive_t buffer::get_elements_type() const
{
    return type;
}


/**
  * Return the sizes of the dimensions of the buffer.
  * Assuming the following buffer: buf[N0][N1][N2].  The first
  * vector element represents the size of rightmost dimension
  * of the buffer (i.e. N2), the second vector element is N1,
  * and the last vector element is N0.
  */
const std::vector<tiramisu::expr> &buffer::get_dim_sizes() const
{
    return dim_sizes;
}


void tiramisu::buffer::dump(bool exhaustive) const
{
    if (ENABLE_DEBUG)
    {
        std::cout << "Buffer \"" << this->name
                  << "\", Number of dimensions: " << this->nb_dims
                  << std::endl;

        std::cout << "Dimension sizes: ";
        for (auto size: dim_sizes)
        {
          // TODO: create_halide_expr_from_tiramisu_expr does not support
          // the case where the buffer size is a computation access.
            std::vector<isl_ast_expr *> ie = {};
            std::cout << halide_expr_from_tiramisu_expr(NULL, ie, size) << ", ";
        }

        std::cout << std::endl;

        std::cout << "Elements type: "
                  << str_from_tiramisu_type_primitive(this->type) << std::endl;

        std::cout << "Function field: "
                  << str_from_is_null(this->fct) << std::endl;

        std::cout << "Argument type: "
                  << str_from_tiramisu_type_argument(this->argtype) << std::endl;

        std::cout<< std::endl << std::endl;
    }
}

Halide::Type halide_type_from_tiramisu_type(tiramisu::primitive_t type)
{
    Halide::Type t;

    switch (type)
    {
        case tiramisu::p_uint8:
            t = Halide::UInt(8);
            break;
        case tiramisu::p_int8:
            t = Halide::Int(8);
            break;
        case tiramisu::p_uint16:
            t = Halide::UInt(16);
            break;
        case tiramisu::p_int16:
            t = Halide::Int(16);
            break;
        case tiramisu::p_uint32:
            t = Halide::UInt(32);
            break;
        case tiramisu::p_int32:
            t = Halide::Int(32);
            break;
        case tiramisu::p_uint64:
            t = Halide::UInt(64);
            break;
        case tiramisu::p_int64:
            t = Halide::Int(64);
            break;
        case tiramisu::p_float32:
            t = Halide::Float(32);
            break;
        case tiramisu::p_float64:
            t = Halide::Float(64);
            break;
        case tiramisu::p_boolean:
            t = Halide::Bool();
            break;
        default:
            tiramisu::error("Tiramisu type cannot be translated to Halide type.", true);
    }
    return t;
}

isl_map* tiramisu::computation::update_let_stmt_schedule_domain_name(isl_map* map)
{
    DEBUG_FCT_NAME(10);
    DEBUG_INDENT(4);

    DEBUG(10, tiramisu::str_dump ("Updating the domain of schedule."));
    DEBUG(10, tiramisu::str_dump ("Input schedule: ", isl_map_to_str(map)));

    // Get the computation,
    // Check if the computation is a let stmt, if it is the case
    // check if it starts with LET_STMT_PREFIX, if not add it automatically.
    std::string comp_name = isl_map_get_tuple_name(map, isl_dim_in);
    assert(comp_name.size() > 0);

    tiramisu::computation* let_comp =
            this->get_function()->get_computation_by_name(comp_name);

    if (let_comp == NULL)    // i.e. if let computation not found
        DEBUG(10, tiramisu::str_dump ("Computation used in the domain not found."));

    DEBUG(10, tiramisu::str_dump ("Output schedule: ", isl_map_to_str(map)));
    DEBUG_INDENT(-4);

    return map;
}

//----------------

/**
  * Initialize a computation
  *  This is a private function that should not be called explicitly
  * by users.
  */
void tiramisu::computation::init_computation(std::string iteration_space_str,
                      tiramisu::function *fct,
                      const tiramisu::expr &e,
                      bool schedule_this_computation,
                      tiramisu::primitive_t t)
{
        assert(fct != NULL);
        assert(iteration_space_str.length()>0 && ("Empty iteration space"));

        // Initialize all the fields to NULL (useful for later asserts)
        access = NULL;
        schedule = NULL;
        stmt = Halide::Internal::Stmt();
        time_processor_domain = NULL;
        relative_order = 0;

        this->statements_to_compute_before_me = NULL;
        this->schedule_this_computation = schedule_this_computation;
        this->data_type = t;
        this->expression = e;

        this->ctx = fct->get_ctx();

        iteration_domain = isl_set_read_from_str(ctx, iteration_space_str.c_str());
        name = std::string(isl_space_get_tuple_name(isl_set_get_space(iteration_domain), isl_dim_type::isl_dim_set));
        function = fct;
        function->add_computation(this);
        this->set_identity_schedule_based_on_iteration_domain();
    }

/**
 * Dummy constructor for derived classes.
 */
tiramisu::computation::computation()
{
    access = NULL;
    schedule = NULL;
    stmt = Halide::Internal::Stmt();
    time_processor_domain = NULL;
    relative_order = 0;

    this->schedule_this_computation = false;
    this->data_type = p_none;
    this->expression = tiramisu::expr();
    this->statements_to_compute_before_me = NULL;

    this->ctx = NULL;

    iteration_domain = NULL;
    name = "";
    function = NULL;
    _is_let_stmt = false;
}

/**
  * Constructor for computations.
  *
  * \p iteration_domain_str is a string that represents the iteration
  * domain of the computation.  The iteration domain should be written
  * in the ISL format (http://isl.gforge.inria.fr/user.html#Sets-and-Relations).
  *
  * The iteration domain of a statement is a set that contains
  * all of the execution instances of the statement (a statement in a
  * loop has an execution instance for each loop iteration in which
  * it executes). Each execution instance of a statement in a loop
  * nest is uniquely represented by an identifier and a tuple of
  * integers  (typically,  the  values  of  the  outer  loop  iterators).
  *
  * For example, the iteration space of the statement S0 in the following
  * loop nest
  * for (i=0; i<2; i++)
  *   for (j=0; j<3; j++)
  *      S0;
  *
  * is {S0(0,0), S0(0,1), S0(0,2), S0(1,0), S0(1,1), S0(1,2)}
  *
  * S0(0,0) is the execution instance of S0 in the iteration (0,0).
  *
  * The previous set of integer tuples can be compactly described
  * by affine constraints as follows
  *
  * {S0(i,j): 0<=i<2 and 0<=j<3}
  *
  * In general, the loop nest
  *
  * for (i=0; i<N; i++)
  *   for (j=0; j<M; j++)
  *      S0;
  *
  * has the following iteration domain
  *
  * {S0(i,j): 0<=i<N and 0<=j<M}
  *
  * This should be read as: the set of points (i,j) such that
  * 0<=i<N and 0<=j<M.
  *
  * \p e is the expression computed by the computation.
  *
  * \p schedule_this_computation should be set to true if the computation
  * is supposed to be schedule and code is supposed to be generated from
  * the computation.  Set it to false if you just want to use the
  * computation to represent a buffer (that is passed as an argument
  * to the function) and you do not intend to generate code for the
  * computation.
  *
  * \p t is the type of the computation, i.e. the type of the expression
  * computed by the computation. Example of types include (p_uint8,
  * p_uint16, p_uint32, ...).
  *
  * \p fct is a pointer to the Tiramisu function where this computation
  * should be added.
  *
  * TODO: copy ISL format for sets.
  */
tiramisu::computation::computation(std::string iteration_domain_str, tiramisu::expr e,
            bool schedule_this_computation, tiramisu::primitive_t t,
            tiramisu::function *fct) {
    init_computation(iteration_domain_str, fct, e,
                     schedule_this_computation, t);
    _is_let_stmt = false;
}

/**
  * Return true if the this computation is supposed to be scheduled
  * by Tiramisu.
  */
bool tiramisu::computation::should_schedule_this_computation() const
{
    return schedule_this_computation;
}

/**
  * Return the access function of the computation.
  */
isl_map *tiramisu::computation::get_access_relation() const
{
    return access;
}

/**
  * Return the access function of the computation after transforming
  * it to the time-processor domain.
  * The domain of the access function is transformed to the
  * time-processor domain using the schedule, and then the transformed
  * access function is returned.
  */
isl_map *tiramisu::computation::get_access_relation_adapted_to_time_processor_domain() const
{
      DEBUG_FCT_NAME(3);
      DEBUG_INDENT(4);

      isl_map *access = this->get_access_relation();

      if (this->is_let_stmt() == false)
      {
          DEBUG(3, tiramisu::str_dump("Original access:", isl_map_to_str(access)));

          if (global::is_auto_data_mapping_set() == true)
          {
              assert(access != NULL);
              assert(this->get_schedule() != NULL);

              DEBUG(3, tiramisu::str_dump("Schedule to apply:", isl_map_to_str(this->get_schedule())));
              access = isl_map_apply_domain(
                          isl_map_copy(access),
                          isl_map_copy(this->get_schedule()));
              DEBUG(3, tiramisu::str_dump("Transformed access:", isl_map_to_str(access)));
          }
          else
              DEBUG(3, tiramisu::str_dump("Access not transformed"));
      }

      DEBUG_INDENT(-4);

      return access;
}

/**
 * Return the Tiramisu expression associated with the computation.
 */
const tiramisu::expr &tiramisu::computation::get_expr() const
{
    return expression;
}

/**
  * Return the function where the computation is declared.
  */
tiramisu::function *tiramisu::computation::get_function() const
{
    return function;
}

/**
  * Return vector of isl_ast_expr representing the indices of the array where
  * the computation will be stored.
  */
std::vector<isl_ast_expr *> &tiramisu::computation::get_index_expr()
{
    return index_expr;
}

/**
  * Return the iteration domain of the computation.
  * In this representation, the order of execution of computations
  * is not specified, the computations are also not mapped to memory.
  */
isl_set *tiramisu::computation::get_iteration_domain() const
{
    // Every computation should have an iteration space.
    assert(iteration_domain != NULL);

    return iteration_domain;
}

/**
  * Return the time-processor domain of the computation.
  * In this representation, the logical time of execution and the
  * processor where the computation will be executed are both
  * specified.
  */
isl_set *tiramisu::computation::get_time_processor_domain() const
{
    return time_processor_domain;
}

/**
  * Return the schedule of the computation.
  */
isl_map *tiramisu::computation::get_schedule() const
{
    return this->schedule;
}

/**
 * Return if this computation represents a let statement.
 */
bool tiramisu::computation::is_let_stmt() const
{
    return _is_let_stmt;
}

/**
  * Return the name of the computation.
  */
const std::string &tiramisu::computation::get_name() const
{
    return name;
}

/**
  * Return the context of the computations.
  */
isl_ctx *tiramisu::computation::get_ctx() const
{
    return ctx;
}

/**
 * Get the number of dimensions of the iteration
 * domain of the computation.
 */
int tiramisu::computation::get_n_dimensions()
{
  assert(iteration_domain != NULL);

  return isl_set_n_dim(this->iteration_domain);
}

/**
 * Get the data type of the computation.
 */
tiramisu::primitive_t tiramisu::computation::get_data_type() const
{
  return data_type;
}

/**
  * Return the Halide statement that assigns the computation to a buffer location.
  */
Halide::Internal::Stmt tiramisu::computation::get_halide_stmt() const
{
    return stmt;
}

/**
 * Compare two computations.
 *
 * Two computations are considered to be equal if they have the
 * same name.
 */
bool tiramisu::computation::operator==(tiramisu::computation comp1)
{
  if (this->get_name() == comp1.get_name())
    return true;
  else
    return false;
}

/**
  * Generate the time-processor domain of the computation.
  *
  * In this representation, the logical time of execution and the
  * processor where the computation will be executed are both
  * specified.  The memory location where computations will be
  * stored in memory is not specified at the level.
  */
void tiramisu::computation::gen_time_processor_domain()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    assert(this->get_iteration_domain() != NULL);
    assert(this->get_schedule() != NULL);

    time_processor_domain = isl_set_apply(
        isl_set_copy(this->get_iteration_domain()),
        isl_map_copy(this->get_schedule()));

    DEBUG(3, tiramisu::str_dump("Iteration domain:", isl_set_to_str(this->get_iteration_domain())));
    DEBUG(3, tiramisu::str_dump("Schedule:", isl_map_to_str(this->get_schedule())));
    DEBUG(3, tiramisu::str_dump("Generated time-space domain:", isl_set_to_str(time_processor_domain)));

    DEBUG_INDENT(-4);
}

void tiramisu::computation::set_access(isl_map *access)
{
    assert(access != NULL);

    this->access = access;
}

/**
 * Set the access function of the computation.
 *
 * The access function is a relation from computations to buffer locations.
 * \p access_str is a string that represents the relation (in ISL format,
 * http://isl.gforge.inria.fr/user.html#Sets-and-Relations).
 */
void tiramisu::computation::set_access(std::string access_str)
{
    assert(access_str.length() > 0);

    this->access = isl_map_read_from_str(this->ctx, access_str.c_str());

    /**
     * Search for any other computation that starts with
     * "_" and that has the same name.  That computation
     * was split from this computation.
     *
     * For now we assume that only one such computation exists
     * (we check in the separate function that each computation
     * is separated only once, separated computations cannot be
     * separated themselves).
     */
    tiramisu::computation *separated_computation = this->get_function()->get_computation_by_name("_"+this->get_name());

    if (separated_computation != NULL)
    {
        int pos = access_str.find(this->get_name());
        int len = this->get_name().length();

        access_str.replace(pos, len, "_"+this->get_name());
        separated_computation->access = isl_map_read_from_str(separated_computation->ctx, access_str.c_str());

        assert(separated_computation->access != NULL);
    }

    assert(this->access != NULL);
}

/**
 * Generate an identity schedule for the computation.
 *
 * This identity schedule is an identity relation created from the iteration
 * domain.
 */
isl_map *tiramisu::computation::gen_identity_schedule_for_iteration_domain()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_space *sp = isl_set_get_space(this->get_iteration_domain());
    isl_map *sched = isl_map_identity(isl_space_map_from_set(sp));
    sched = isl_map_intersect_domain(
        sched, isl_set_copy(this->get_iteration_domain()));
    sched = isl_map_coalesce(sched);

    // Add Beta dimensions.
    for (int i=0; i<isl_space_dim(sp, isl_dim_out)+1; i++)
        sched = isl_map_add_dim_and_eq_constraint(sched, 2*i, 0);

    DEBUG_INDENT(-4);

    return sched;
}

/**
 * Generate an identity schedule for the computation.
 *
 * This identity schedule is an identity relation created from the
 * time-processor domain.
 */
isl_map *tiramisu::computation::gen_identity_schedule_for_time_space_domain()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_space *sp = isl_set_get_space(this->get_time_processor_domain());
    isl_map *sched = isl_map_identity(isl_space_map_from_set(sp));
    sched = isl_map_intersect_domain(
        sched, isl_set_copy(this->get_time_processor_domain()));
    sched = isl_map_set_tuple_name(sched, isl_dim_out, "");
    sched = isl_map_coalesce(sched);

    DEBUG_INDENT(-4);

    return sched;
}

/**
 * Set an identity schedule for the computation.
 *
 * This identity schedule is an identity relation created from the iteration
 * domain.
 */
void tiramisu::computation::set_identity_schedule_based_on_iteration_domain()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    isl_map *sched = this->gen_identity_schedule_for_iteration_domain();
    DEBUG(3, tiramisu::str_dump("The following identity schedule is set: ",
                            isl_map_to_str(sched)));
    this->set_schedule(sched);

    DEBUG_INDENT(-4);
}

/**
  * Set the schedule indicated by \p map.
  *
  * \p map is a string that represents a mapping from the iteration domain
  *  to the time-processor domain (the mapping is in the ISL format:
  *  http://isl.gforge.inria.fr/user.html#Sets-and-Relations).
  *
  * TODO: specify clearly the expected format for the schedule.
  *
  * The name of the domain and range space must be identical.
  */
void tiramisu::computation::set_schedule(isl_map *map)
{
    this->schedule = map;
}

/**
 * Set the expression of the computation.
 */
void tiramisu::computation::set_expression(const tiramisu::expr &e)
{
    this->expression = e;
}

/**
 * Set the name of the computation.
 */
void tiramisu::computation::set_name(const std::string n)
{
    this->name = n;
}

/**
  * Bind the computation to a buffer.
  * i.e. create a one-to-one data mapping between the computation
  * the buffer.
  */
void tiramisu::computation::bind_to(buffer *buff)
{
    assert(buff != NULL);

    isl_space *sp = isl_set_get_space(this->get_iteration_domain());
    isl_map *map = isl_map_identity(isl_space_map_from_set(sp));
    map = isl_map_intersect_domain(
        map, isl_set_copy(this->get_iteration_domain()));
    map = isl_map_set_tuple_name(map, isl_dim_out, buff->get_name().c_str());
    map = isl_map_coalesce(map);
    DEBUG(2, tiramisu::str_dump("\nBinding.  The following access function is set: ",
                            isl_map_to_str(map)));
    this->set_access(isl_map_to_str(map));
}

void tiramisu::computation::mark_as_let_statement()
{
    this->_is_let_stmt = true;
}

/****************************************************************************
 ****************************************************************************
 ***************************** Constant class *******************************
 ****************************************************************************
 ****************************************************************************/

tiramisu::constant::constant(std::string param_name, const tiramisu::expr &param_expr,
         tiramisu::primitive_t t,
         bool function_wide,
         tiramisu::computation *with_computation,
         int at_loop_level,
         tiramisu::function *func): tiramisu::computation()
{
    DEBUG_FCT_NAME(3);
    DEBUG_INDENT(4);

    assert((param_name.length() > 0) && "Parameter name empty");
    assert((func != NULL) && "Function undefined");
    assert(((function_wide && !with_computation) || (!function_wide && with_computation)) && "with_computation, should be set only if function_wide is false");

    DEBUG(3, tiramisu::str_dump("Declaring a constant."));

    if (function_wide)
    {
        this->set_name(param_name);
        this->set_expression(param_expr);
        func->add_invariant(*this);
        this->mark_as_let_statement();
    }
    else
    {
        assert((with_computation != NULL) &&
               "A valid computation should be provided.");
        assert((at_loop_level >= computation::root_dimension) &&
               "Invalid root dimension.");

        isl_set *iter = with_computation->get_iteration_domain();
        int projection_dimension = at_loop_level+1;
        iter = isl_set_project_out(isl_set_copy(iter),
                                   isl_dim_set,
                                   projection_dimension,
                                   isl_set_dim(iter, isl_dim_set)
                                   -projection_dimension);
        iter = isl_set_set_tuple_name(iter, param_name.c_str());
        std::string iteration_domain_str = isl_set_to_str(iter);

        DEBUG(3, tiramisu::str_dump(
                    "Computed iteration space for the constant assignment",
                    isl_set_to_str(iter)));

        init_computation(iteration_domain_str, func, param_expr,
                               true, t);

        this->mark_as_let_statement();

        DEBUG_NO_NEWLINE(10,
                 tiramisu::str_dump("The computation representing the assignment:");
                 this->dump(true));

        assert(with_computation != NULL);
        // Compute this statement before computing the "with_coputation".
        // Since this statement is a let statement the "with_computation"
        // will consumer it.
        with_computation->statements_to_compute_before_me = this;

        // Set the schedule of this computation to be executed
        // before the computation.
        this->before(*with_computation, at_loop_level);
    }
    DEBUG_INDENT(-4);
}

void tiramisu::constant::dump(bool exhaustive) const
{
    if (ENABLE_DEBUG)
    {
        std::cout << "Invariant \"" << this->get_name() << "\"" << std::endl;

        std::cout << "Expression: ";
        this->get_expr().dump(exhaustive);
        std::cout << std::endl;
    }
}

}
