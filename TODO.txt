High Priority
---------------
- Urgent features:
	- API interface:
        - Add the ability to access buffers directly from coli expressions,
		- API: simplify the interface and make it stable,
        - Vectorize a non-affine loop (split with the innermost being constant):
        	- Add the isolate option which isolates the full loops.
		- API: create three types for computations: definition, update, reductions (indicating the reduction dimension),
	- Performance:
		- Matmul,
		- Blurxy,
	- Non affine support:
        - Non affine conditionals,


    - Patricia:
			- API: solve the problem of the order of computation declaration,
			- API: create a map from iterator names to iterator numbers and update that map automatically with the schedule updates,

	- Optional
		- API: documentation,
		- Write one page latex document describing COLi,
		- Write test cases,
		- Fix dumping,
		- Add is_defined() to all the classes,
		- Dump should respect the indentation.
	- Testing:
        - Test correctness of blurxy,
        - Add asserts to check my assumptions,
        - Write basic tests.
	- Robustness:
        - Work on robust translation from coli accesses into an access function.
        Currently I support only very simple accesses (add, sub).
        - Currently if you specify an access function that has constraints, the
        constraints are not taken in consideration.  The access function is
        applied for all the values of i and j.

- Low priority:
		- Support type casting.
		- Differentiate between select and ifTheElse.
		- Support ramp, broadcast.
		- Create a free and allocate IR nodes:
			- The function that creates a let stmt should return a structure with the stmt
			and the type of the stmt.  If the statement is empty but its type is let, free
			or alloc then generate these.  
		- Call external functions.
		- Support .inline() which inlines computations.
        - Add scheduling commands: .fuse(), .split(), and .duplicate().
        - split() and interchange() should be done regourously using real ISL
        constraint (floor should be expressed as ISL constraints).
        Now setting the space names is flicky.
        - Whether a given optimization (parallelization, ...) can be applied or not,
        depends on the type of the computation.  Reduction for example cannot be
        parallelized on the reduction dimension.
        - compute_halide_call_graph().


- Benchmarks:
	- Image processing (Halide)
		- Blur,
		- Sobel edge detection,
		- Bilateral grid,
		- Camera pipeline,
		- Local Laplacian filters,
		- Multi-scale interpolation,
	- TensorFlow.
	- Simit.


Low Priority
-------------
- Data layout
    - Test buffer access linearization for buffers with more than 3 dimensions.
     Buffer access linearization is now done in
     Computation::create_halide_assignement(std::vector<std::string> &iterators).


- General
   - Currently all loop iterators have an Int32 type.  Users should be able to
   choose which data type they can use (this is important to support loops over
   very large datasets).
   - Create a class "Buffer" to be used instead of using the Halide buffer
   class.  The Halide::Buffer class should only be used during code
   generation.  Currently Halide can only handle 3D arrays, make sure you
   check for this during code generation.
   - Support more isl_ast expressions in create_halide_expr_from_isl_ast_expr.
   - Support data type conversion.  Currently the loop bound (invariant) has
     to be declared explicitely to be "int32_t" in order to have the same
     type as the loop iterator, but in the future automatic data conversion
     should be done.
   - Mark the getter method as const and the returned type of constant (especially
   if you return a pointer) if you don't mean for the user to modify it. For
   example, buffer::get_data returns pointer to data, but I can't really tell
   whether you expect the user to not modify it or if it is okay if I
   re-write the data.
   - Print all the information of a classes.

- Building and compiling
   - ISL, Halide should be distributed with COLi and should be
   compiled automatically.
   - Compile COLi into one shared library.

- Assumptions:
	- No computation should be added after scheduling.
	- Check that the space of the domain of the access is equal to the
	space of the dmain of the corresponding computation.
	- While in ISL the names of dimensions is not important, the dimension
	names in COLi is important (this is because we need to match the indices
	of coli access expressions to the dimensions of the access function).
- Advantages over Halide:
	- All what min could not do,
	- Fuse/distribute,
	- Mapping to data,


Design questions
------------------
- Do we need binding of data to computations ?
