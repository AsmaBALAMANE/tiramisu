High Priority
---------------
- Urgent features:
    - Halide features:
		- Non affine array accesses,
        - Vectorize a non-affine loop (split with the innermost being constant).
	- Non affine support:
        - Non affine conditionals,
	- Testing:
        - Test correctness of blurxy,
        - Add asserts to check my assumptions,
        - Write basic tests.
	- Robustness:
        - Work on robust translation from coli accesses into an access function.
        Currently I support only very simple accesses (add, sub).
        - Currently if you specify an access function that has constraints, the
        constraints are not taken in consideration.  The access function is
        applied for all the values of i and j.
	- Light:
		- Create three types for computations:
			- Tyes: definition, update, reductions (indicating the reduction dimension),
		- Support automatic binding,

- Low priority:
		- Support type casting.
		- Differentiate between select and ifTheElse.
		- Support ramp, broadcast.
		- Create a free and allocate IR nodes.
		- Support two types of conditionals.
		- Call external functions.
		- compute_halide_call_graph().
        - split() and interchange() should be done regourously using real ISL
        constraint (floor should be expressed as ISL constraints).
        Now setting the space names is flicky.
        - Support .inline() which inlines computations.
        - Add scheduling commands: .fuse(), .split(), and .duplicate().
        - Whether a given optimization (parallelization, ...) can be applied or not,
        depends on the type of the computation.  Reduction for example cannot be
        parallelized on the reduction dimension.


- Benchmarks:
	- Image processing (Halide)
		- Blur,
		- Sobel edge detection,
		- Bilateral grid,
		- Camera pipeline,
		- Local Laplacian filters,
		- Multi-scale interpolation,
	- TensorFlow.
	- Simit.


Low Priority
-------------
- Data layout
    - Test buffer access linearization for buffers with more than 3 dimensions.
     Buffer access linearization is now done in
     Computation::create_halide_assignement(std::vector<std::string> &iterators).


- General
   - Currently all loop iterators have an Int32 type.  Users should be able to
   choose which data type they can use (this is important to support loops over
   very large datasets).
   - Create a class "Buffer" to be used instead of using the Halide buffer
   class.  The Halide::Buffer class should only be used during code
   generation.  Currently Halide can only handle 3D arrays, make sure you
   check for this during code generation.
   - Support more isl_ast expressions in create_halide_expr_from_isl_ast_expr.
   - Support data type conversion.  Currently the loop bound (invariant) has
     to be declared explicitely to be "int32_t" in order to have the same
     type as the loop iterator, but in the future automatic data conversion
     should be done.
   - Mark the getter method as const and the returned type of constant (especially
   if you return a pointer) if you don't mean for the user to modify it. For
   example, buffer::get_data returns pointer to data, but I can't really tell
   whether you expect the user to not modify it or if it is okay if I
   re-write the data.
   - Print all the information of a classes.

- Building and compiling
   - ISL, Halide should be distributed with COLi and should be
   compiled automatically.
   - Compile COLi into one shared library.

- Assumptions:
	- No computation should be added after scheduling.
	- Check that the space of the domain of the access is equal to the
	space of the dmain of the corresponding computation.
	- While in ISL the names of dimensions is not important, the dimension
	names in COLi is important (this is because we need to match the indices
	of coli access expressions to the dimensions of the access function).
- Advantages over Halide:
	- All what min could not do,
	- Fuse/distribute,
	- Mapping to data,


Design questions
------------------
- Do we need binding of data to computations ?
