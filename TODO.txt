High Priority
--------------
- Time-processor representation
	OK- The user specifies the iteration space.
	OK- The user specifies the schedule and tags.
	OK- computation.gen_time_space_IR()
		OK-- Assert iteration space and schedule are provided.
		OK-- Applies the schedule on the iteration space.
	OK- The user specifies the mapping from time space to memory buffers.
	- Apply the schedule on the memory mapping,
    	- Assert that the spaces of the schedule, data mapping are compatible
	(same number of dimensions, same tuple name, ...).
	OK- Generate code:
		OK- The identity schedule is used.


- Scheduling
    - Assert that a schedule, an access function are provided before code
    generation.
    - All schedules should be aligned before scheduling otherwise shorter
    times will be considered small lexicographically.
    - Currently, when multiple computations are declared, users can specify the
    order between these computations only when the explicit schedule time is
    specified.  Enable users to express the order between computations if the
    .Tile(), .Split(), ... is used.
    - Tiling: support tiling when the loop size is not multiple of tile size.
    - Add Fusion(), Distribution() commands.


- Halide support
	- Add a vector of parameters to the function class.
	- New class parameters:
		- a class to represent iteration set parameters.
		- during code generation, parameters are generated before any loops start
		  to be generated.  Parameters are supposed to constant throughout the whole
		  program.
	- Changes on the computation class:
      		- The constructor should not take a Halide expression, the Halide expression
		  is now set using a separate function.
		- Add the binding function which simply sets the access function of a
		  computation to a buffer (one-to-one).
		- Add flag is_binded to a computation to check if it binded to a variable.  When generating code,
		check that the arguments are all binded.  Currently we do not support unbinded arguments.
		- Computation arguments should be transformed into computations.
	- compute_halide_call_graph().


- Data layout
    - Currently if you specify an access function that has constraints,
    the constraints are not taken in consideration.  The access function is
    applied for all the values of i and j.


Low Priority
-------------
- Data layout
    - Test buffer access linearization for buffers with more than 3 dimensions.
     Buffer access linearization is now done in
     Computation::create_halide_assignement(std::vector<std::string> &iterators).
    - Check if the declaration of an array with a symbolic constant size is
    possible.

- General
   - Trnasform computations_list from a global variable into a non global
   variable.
   - Currently all loop iterators have an Int32 type.  Users should be able to
   choose which data type they can use (this is important to support loops over
   very large datasets).
   - Create a class "Buffer" to be used instead of using the Halide buffer
   class.  The Halide::Buffer class should only be used during code
   generation.  Currently Halide can only handle 3D arrays, make sure you
   check for this during code generation.

- Building and compiling
   - ISL, Halide should be distributed with COLi and should be
   compiled automatically.
   - Compile COLi into one shared library.
